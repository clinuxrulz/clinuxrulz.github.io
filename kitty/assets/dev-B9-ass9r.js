let Qe=1,pe=!1,we=!1,X=[],U=null,be=null,Je=5,de=0,Ze=300,me=null,re=null;const et=1073741823;function tt(){const e=new MessageChannel,t=e.port2;if(me=()=>t.postMessage(null),e.port1.onmessage=()=>{if(re!==null){const r=performance.now();de=r+Je;const n=!0;try{re(n,r)?t.postMessage(null):re=null}catch(s){throw t.postMessage(null),s}}},navigator&&navigator.scheduling&&navigator.scheduling.isInputPending){const r=navigator.scheduling;be=()=>{const n=performance.now();return n>=de?r.isInputPending()?!0:n>=Ze:!1}}else be=()=>performance.now()>=de}function nt(e,t){function r(){let n=0,s=e.length-1;for(;n<=s;){const i=s+n>>1,l=t.expirationTime-e[i].expirationTime;if(l>0)n=i+1;else if(l<0)s=i-1;else return i}return n}e.splice(r(),0,t)}function Me(e,t){me||tt();let r=performance.now(),n=et;t&&t.timeout&&(n=t.timeout);const s={id:Qe++,fn:e,startTime:r,expirationTime:r+n};return nt(X,s),!pe&&!we&&(pe=!0,re=rt,me()),s}function kt(e){e.fn=null}function rt(e,t){pe=!1,we=!0;try{return st(e,t)}finally{U=null,we=!1}}function st(e,t){let r=t;for(U=X[0]||null;U!==null&&!(U.expirationTime>r&&(!e||be()));){const n=U.fn;if(n!==null){U.fn=null;const s=U.expirationTime<=r;n(s),r=performance.now(),U===X[0]&&X.shift()}else X.shift();U=X[0]||null}return U!==null}const h={context:void 0,registry:void 0,effects:void 0,done:!1,getContextId(){return Ee(this.context.count)},getNextContextId(){return Ee(this.context.count++)}};function Ee(e){const t=String(e),r=t.length-1;return h.context.id+(r?String.fromCharCode(96+r):"")+t}function N(e){h.context=e}function it(){return{...h.context,id:h.getNextContextId(),count:0}}const Fe=(e,t)=>e===t,ie=Symbol("solid-proxy"),Ve=typeof Proxy=="function",Re=Symbol("solid-track"),Le=Symbol("solid-dev-component"),le={equals:Fe};let D=null,De=Ke;const F=1,J=2,lt={owned:null,cleanups:null,context:null,owner:null},he={};var f=null;let o=null,B=null,$=null,p=null,v=null,E=null,ae=0;const W={afterUpdate:null,afterCreateOwner:null,afterCreateSignal:null};function z(e,t){const r=p,n=f,s=e.length===0,i=t===void 0?n:t,l=s?{owned:null,cleanups:null,context:null,owner:null}:{owned:null,cleanups:null,context:i?i.context:null,owner:i},u=s?()=>e(()=>{throw new Error("Dispose method must be an explicit argument to createRoot function")}):()=>e(()=>A(()=>Y(l)));W.afterCreateOwner&&W.afterCreateOwner(l),f=l,p=null;try{return V(u,!0)}finally{p=r,f=n}}function M(e,t){t=t?Object.assign({},le,t):le;const r={value:e,observers:null,observerSlots:null,comparator:t.equals||void 0};t.name&&(r.name=t.name),W.afterCreateSignal&&W.afterCreateSignal(r),t.internal||qe(r);const n=s=>(typeof s=="function"&&(o&&o.running&&o.sources.has(r)?s=s(r.tValue):s=s(r.value)),Ce(r,s));return[_e.bind(r),n]}function Te(e,t,r){const n=K(e,t,!0,F,r);B&&o&&o.running?v.push(n):q(n)}function ut(e,t,r){const n=K(e,t,!1,F,r);B&&o&&o.running?v.push(n):q(n)}function Ne(e,t,r){De=wt;const n=K(e,t,!1,F,r),s=_&&ee(_);s&&(n.suspense=s),(!r||!r.render)&&(n.user=!0),E?E.push(n):q(n)}function Ct(e,t){let r;const n=K(()=>{r?r():A(e),r=void 0},void 0,!1,0,t),s=_&&ee(_);return s&&(n.suspense=s),n.user=!0,i=>{r=i,q(n)}}function P(e,t,r){r=r?Object.assign({},le,r):le;const n=K(e,t,!0,0,r);return n.observers=null,n.observerSlots=null,n.comparator=r.equals||void 0,B&&o&&o.running?(n.tState=F,v.push(n)):q(n),_e.bind(n)}function ot(e){return e&&typeof e=="object"&&"then"in e}function at(e,t,r){let n,s,i;arguments.length===2&&typeof t=="object"||arguments.length===1?(n=!0,s=e,i=t||{}):(n=e,s=t,i=r||{});let l=null,u=he,a=null,d=!1,g=!1,c="initialValue"in i,y=typeof n=="function"&&P(n);const w=new Set,[S,m]=(i.storage||M)(i.initialValue),[j,I]=M(void 0),[b,k]=M(void 0,{equals:!1}),[T,L]=M(c?"ready":"unresolved");h.context&&(a=h.getNextContextId(),i.ssrLoadFrom==="initial"?u=i.initialValue:h.load&&h.has(a)&&(u=h.load(a)));function R(x,C,O,G){return l===x&&(l=null,G!==void 0&&(c=!0),(x===u||C===u)&&i.onHydrated&&queueMicrotask(()=>i.onHydrated(G,{value:C})),u=he,o&&x&&d?(o.promises.delete(x),d=!1,V(()=>{o.running=!0,Oe(C,O)},!1)):Oe(C,O)),C}function Oe(x,C){V(()=>{C===void 0&&m(()=>x),L(C!==void 0?"errored":c?"ready":"unresolved"),I(C);for(const O of w.keys())O.decrement();w.clear()},!1)}function ce(){const x=_&&ee(_),C=S(),O=j();if(O!==void 0&&!l)throw O;return p&&!p.user&&x&&Te(()=>{b(),l&&(x.resolved&&o&&d?o.promises.add(l):w.has(x)||(x.increment(),w.add(x)))}),C}function fe(x=!0){if(x!==!1&&g)return;g=!1;const C=y?y():n;if(d=o&&o.running,C==null||C===!1){R(l,A(S));return}o&&l&&o.promises.delete(l);const O=u!==he?u:A(()=>s(C,{value:S(),refetching:x}));return ot(O)?(l=O,"value"in O?(O.status==="success"?R(l,O.value,void 0,C):R(l,void 0,ye(O.value),C),O):(g=!0,queueMicrotask(()=>g=!1),V(()=>{L(c?"refreshing":"pending"),k()},!1),O.then(G=>R(O,G,void 0,C),G=>R(O,void 0,ye(G),C)))):(R(l,O,void 0,C),O)}return Object.defineProperties(ce,{state:{get:()=>T()},error:{get:()=>j()},loading:{get(){const x=T();return x==="pending"||x==="refreshing"}},latest:{get(){if(!c)return ce();const x=j();if(x&&!l)throw x;return S()}}}),y?Te(()=>fe(!1)):fe(!1),[ce,{refetch:fe,mutate:m}]}function Ot(e,t){let r,n=t?t.timeoutMs:void 0;const s=K(()=>((!r||!r.fn)&&(r=Me(()=>l(()=>s.value),n!==void 0?{timeout:n}:void 0)),e()),void 0,!0),[i,l]=M(o&&o.running&&o.sources.has(s)?s.tValue:s.value,t);return q(s),l(()=>o&&o.running&&o.sources.has(s)?s.tValue:s.value),i}function Et(e,t=Fe,r){const n=new Map,s=K(i=>{const l=e();for(const[u,a]of n.entries())if(t(u,l)!==t(u,i))for(const d of a.values())d.state=F,d.pure?v.push(d):E.push(d);return l},void 0,!0,F,r);return q(s),i=>{const l=p;if(l){let u;(u=n.get(i))?u.add(l):n.set(i,u=new Set([l])),H(()=>{u.delete(l),!u.size&&n.delete(i)})}return t(i,o&&o.running&&o.sources.has(s)?s.tValue:s.value)}}function Tt(e){return V(e,!1)}function A(e){if(!$&&p===null)return e();const t=p;p=null;try{return $?$.untrack(e):e()}finally{p=t}}function Pt(e,t,r){const n=Array.isArray(e);let s,i=r&&r.defer;return l=>{let u;if(n){u=Array(e.length);for(let d=0;d<e.length;d++)u[d]=e[d]()}else u=e();if(i)return i=!1,l;const a=A(()=>t(u,s,l));return s=u,a}}function At(e){Ne(()=>A(e))}function H(e){return f===null?console.warn("cleanups created outside a `createRoot` or `render` will never be run"):f.cleanups===null?f.cleanups=[e]:f.cleanups.push(e),e}function ct(e,t){D||(D=Symbol("error")),f=K(void 0,void 0,!0),f.context={...f.context,[D]:[t]},o&&o.running&&o.sources.add(f);try{return e()}catch(r){te(r)}finally{f=f.owner}}function It(){return p}function Ue(){return f}function jt(e,t){const r=f,n=p;f=e,p=null;try{return V(t,!0)}catch(s){te(s)}finally{f=r,p=n}}function Mt(e=Me){B=e}function $e(e){if(o&&o.running)return e(),o.done;const t=p,r=f;return Promise.resolve().then(()=>{p=t,f=r;let n;return(B||_)&&(n=o||(o={sources:new Set,effects:[],promises:new Set,disposed:new Set,queue:new Set,running:!0}),n.done||(n.done=new Promise(s=>n.resolve=s)),n.running=!0),V(e,!1),p=f=null,n?n.done:void 0})}const[ft,Pe]=M(!1);function Ft(){return[ft,$e]}function dt(e){E.push.apply(E,e),e.length=0}function Ae(e,t){const r=K(()=>A(()=>(Object.assign(e,{[Le]:!0}),e(t))),void 0,!0,0);return r.props=t,r.observers=null,r.observerSlots=null,r.name=e.name,r.component=e,q(r),r.tValue!==void 0?r.tValue:r.value}function qe(e){f&&(f.sourceMap?f.sourceMap.push(e):f.sourceMap=[e],e.graph=f)}function We(e,t){const r=Symbol("context");return{id:r,Provider:bt(r,t),defaultValue:e}}function ee(e){let t;return f&&f.context&&(t=f.context[e.id])!==void 0?t:e.defaultValue}function He(e){const t=P(e),r=P(()=>xe(t()),void 0,{name:"children"});return r.toArray=()=>{const n=r();return Array.isArray(n)?n:n!=null?[n]:[]},r}let _;function ht(){return _||(_=We())}function Vt(e,t=r=>r()){if($){const{factory:r,untrack:n}=$;$={factory:(s,i)=>{const l=r(s,i),u=e(a=>l.track(a),i);return{track:a=>u.track(a),dispose(){u.dispose(),l.dispose()}}},untrack:s=>n(()=>t(s))}}else $={factory:e,untrack:t}}function _e(){const e=o&&o.running;if(this.sources&&(e?this.tState:this.state))if((e?this.tState:this.state)===F)q(this);else{const t=v;v=null,V(()=>ue(this),!1),v=t}if(p){const t=this.observers?this.observers.length:0;p.sources?(p.sources.push(this),p.sourceSlots.push(t)):(p.sources=[this],p.sourceSlots=[t]),this.observers?(this.observers.push(p),this.observerSlots.push(p.sources.length-1)):(this.observers=[p],this.observerSlots=[p.sources.length-1])}return e&&o.sources.has(this)?this.tValue:this.value}function Ce(e,t,r){let n=o&&o.running&&o.sources.has(e)?e.tValue:e.value;if(!e.comparator||!e.comparator(n,t)){if(o){const s=o.running;(s||!r&&o.sources.has(e))&&(o.sources.add(e),e.tValue=t),s||(e.value=t)}else e.value=t;e.observers&&e.observers.length&&V(()=>{for(let s=0;s<e.observers.length;s+=1){const i=e.observers[s],l=o&&o.running;l&&o.disposed.has(i)||((l?!i.tState:!i.state)&&(i.pure?v.push(i):E.push(i),i.observers&&Ye(i)),l?i.tState=F:i.state=F)}if(v.length>1e6){throw v=[],new Error("Potential Infinite Loop Detected.");throw new Error}},!1)}return t}function q(e){if(!e.fn)return;Y(e);const t=ae;Ie(e,o&&o.running&&o.sources.has(e)?e.tValue:e.value,t),o&&!o.running&&o.sources.has(e)&&queueMicrotask(()=>{V(()=>{o&&(o.running=!0),p=f=e,Ie(e,e.tValue,t),p=f=null},!1)})}function Ie(e,t,r){let n;const s=f,i=p;p=f=e;try{n=e.fn(t)}catch(l){return e.pure&&(o&&o.running?(e.tState=F,e.tOwned&&e.tOwned.forEach(Y),e.tOwned=void 0):(e.state=F,e.owned&&e.owned.forEach(Y),e.owned=null)),e.updatedAt=r+1,te(l)}finally{p=i,f=s}(!e.updatedAt||e.updatedAt<=r)&&(e.updatedAt!=null&&"observers"in e?Ce(e,n,!0):o&&o.running&&e.pure?(o.sources.add(e),e.tValue=n):e.value=n,e.updatedAt=r)}function K(e,t,r,n=F,s){const i={fn:e,state:n,updatedAt:null,owned:null,sources:null,sourceSlots:null,cleanups:null,value:t,owner:f,context:f?f.context:null,pure:r};if(o&&o.running&&(i.state=0,i.tState=n),f===null?console.warn("computations created outside a `createRoot` or `render` will never be disposed"):f!==lt&&(o&&o.running&&f.pure?f.tOwned?f.tOwned.push(i):f.tOwned=[i]:f.owned?f.owned.push(i):f.owned=[i]),s&&s.name&&(i.name=s.name),$&&i.fn){const[l,u]=M(void 0,{equals:!1}),a=$.factory(i.fn,u);H(()=>a.dispose());const d=()=>$e(u).then(()=>g.dispose()),g=$.factory(i.fn,d);i.fn=c=>(l(),o&&o.running?g.track(c):a.track(c))}return W.afterCreateOwner&&W.afterCreateOwner(i),i}function Z(e){const t=o&&o.running;if((t?e.tState:e.state)===0)return;if((t?e.tState:e.state)===J)return ue(e);if(e.suspense&&A(e.suspense.inFallback))return e.suspense.effects.push(e);const r=[e];for(;(e=e.owner)&&(!e.updatedAt||e.updatedAt<ae);){if(t&&o.disposed.has(e))return;(t?e.tState:e.state)&&r.push(e)}for(let n=r.length-1;n>=0;n--){if(e=r[n],t){let s=e,i=r[n+1];for(;(s=s.owner)&&s!==i;)if(o.disposed.has(s))return}if((t?e.tState:e.state)===F)q(e);else if((t?e.tState:e.state)===J){const s=v;v=null,V(()=>ue(e,r[0]),!1),v=s}}}function V(e,t){if(v)return e();let r=!1;t||(v=[]),E?r=!0:E=[],ae++;try{const n=e();return gt(r),n}catch(n){r||(E=null),v=null,te(n)}}function gt(e){if(v&&(B&&o&&o.running?pt(v):Ke(v),v=null),e)return;let t;if(o){if(!o.promises.size&&!o.queue.size){const n=o.sources,s=o.disposed;E.push.apply(E,o.effects),t=o.resolve;for(const i of E)"tState"in i&&(i.state=i.tState),delete i.tState;o=null,V(()=>{for(const i of s)Y(i);for(const i of n){if(i.value=i.tValue,i.owned)for(let l=0,u=i.owned.length;l<u;l++)Y(i.owned[l]);i.tOwned&&(i.owned=i.tOwned),delete i.tValue,delete i.tOwned,i.tState=0}Pe(!1)},!1)}else if(o.running){o.running=!1,o.effects.push.apply(o.effects,E),E=null,Pe(!0);return}}const r=E;E=null,r.length?V(()=>De(r),!1):W.afterUpdate&&W.afterUpdate(),t&&t()}function Ke(e){for(let t=0;t<e.length;t++)Z(e[t])}function pt(e){for(let t=0;t<e.length;t++){const r=e[t],n=o.queue;n.has(r)||(n.add(r),B(()=>{n.delete(r),V(()=>{o.running=!0,Z(r)},!1),o&&(o.running=!1)}))}}function wt(e){let t,r=0;for(t=0;t<e.length;t++){const n=e[t];n.user?e[r++]=n:Z(n)}if(h.context){if(h.count){h.effects||(h.effects=[]),h.effects.push(...e.slice(0,r));return}N()}for(h.effects&&(h.done||!h.count)&&(e=[...h.effects,...e],r+=h.effects.length,delete h.effects),t=0;t<r;t++)Z(e[t])}function ue(e,t){const r=o&&o.running;r?e.tState=0:e.state=0;for(let n=0;n<e.sources.length;n+=1){const s=e.sources[n];if(s.sources){const i=r?s.tState:s.state;i===F?s!==t&&(!s.updatedAt||s.updatedAt<ae)&&Z(s):i===J&&ue(s,t)}}}function Ye(e){const t=o&&o.running;for(let r=0;r<e.observers.length;r+=1){const n=e.observers[r];(t?!n.tState:!n.state)&&(t?n.tState=J:n.state=J,n.pure?v.push(n):E.push(n),n.observers&&Ye(n))}}function Y(e){let t;if(e.sources)for(;e.sources.length;){const r=e.sources.pop(),n=e.sourceSlots.pop(),s=r.observers;if(s&&s.length){const i=s.pop(),l=r.observerSlots.pop();n<s.length&&(i.sourceSlots[l]=n,s[n]=i,r.observerSlots[n]=l)}}if(e.tOwned){for(t=e.tOwned.length-1;t>=0;t--)Y(e.tOwned[t]);delete e.tOwned}if(o&&o.running&&e.pure)ze(e,!0);else if(e.owned){for(t=e.owned.length-1;t>=0;t--)Y(e.owned[t]);e.owned=null}if(e.cleanups){for(t=e.cleanups.length-1;t>=0;t--)e.cleanups[t]();e.cleanups=null}o&&o.running?e.tState=0:e.state=0,delete e.sourceMap}function ze(e,t){if(t||(e.tState=0,o.disposed.add(e)),e.owned)for(let r=0;r<e.owned.length;r++)ze(e.owned[r])}function ye(e){return e instanceof Error?e:new Error(typeof e=="string"?e:"Unknown error",{cause:e})}function je(e,t,r){try{for(const n of t)n(e)}catch(n){te(n,r&&r.owner||null)}}function te(e,t=f){const r=D&&t&&t.context&&t.context[D],n=ye(e);if(!r)throw n;E?E.push({fn(){je(n,r,t)},state:F}):je(n,r,t)}function xe(e){if(typeof e=="function"&&!e.length)return xe(e());if(Array.isArray(e)){const t=[];for(let r=0;r<e.length;r++){const n=xe(e[r]);Array.isArray(n)?t.push.apply(t,n):t.push(n)}return t}return e}function bt(e,t){return function(n){let s;return ut(()=>s=A(()=>(f.context={...f.context,[e]:n.value},He(()=>n.children))),void 0,t),s}}function Rt(e){D||(D=Symbol("error")),f===null?console.warn("error handlers created outside a `createRoot` or `render` will never be run"):f.context===null||!f.context[D]?(f.context={...f.context,[D]:[e]},se(f,D,[e])):f.context[D].push(e)}function se(e,t,r){if(e.owned)for(let n=0;n<e.owned.length;n++)e.owned[n].context===e.context&&se(e.owned[n],t,r),e.owned[n].context?e.owned[n].context[t]||(e.owned[n].context[t]=r,se(e.owned[n],t,r)):(e.owned[n].context=e.context,se(e.owned[n],t,r))}function Lt(e){return{subscribe(t){if(!(t instanceof Object)||t==null)throw new TypeError("Expected the observer to be an object.");const r=typeof t=="function"?t:t.next&&t.next.bind(t);if(!r)return{unsubscribe(){}};const n=z(s=>(Ne(()=>{const i=e();A(()=>r(i))}),s));return Ue()&&H(n),{unsubscribe(){n()}}},[Symbol.observable||"@@observable"](){return this}}}function Dt(e){const[t,r]=M(void 0,{equals:!1});if("subscribe"in e){const n=e.subscribe(s=>r(()=>s));H(()=>"unsubscribe"in n?n.unsubscribe():n())}else{const n=e(r);H(n)}return t}const ve=Symbol("fallback");function oe(e){for(let t=0;t<e.length;t++)e[t]()}function mt(e,t,r={}){let n=[],s=[],i=[],l=0,u=t.length>1?[]:null;return H(()=>oe(i)),()=>{let a=e()||[],d=a.length,g,c;return a[Re],A(()=>{let w,S,m,j,I,b,k,T,L;if(d===0)l!==0&&(oe(i),i=[],n=[],s=[],l=0,u&&(u=[])),r.fallback&&(n=[ve],s[0]=z(R=>(i[0]=R,r.fallback())),l=1);else if(l===0){for(s=new Array(d),c=0;c<d;c++)n[c]=a[c],s[c]=z(y);l=d}else{for(m=new Array(d),j=new Array(d),u&&(I=new Array(d)),b=0,k=Math.min(l,d);b<k&&n[b]===a[b];b++);for(k=l-1,T=d-1;k>=b&&T>=b&&n[k]===a[T];k--,T--)m[T]=s[k],j[T]=i[k],u&&(I[T]=u[k]);for(w=new Map,S=new Array(T+1),c=T;c>=b;c--)L=a[c],g=w.get(L),S[c]=g===void 0?-1:g,w.set(L,c);for(g=b;g<=k;g++)L=n[g],c=w.get(L),c!==void 0&&c!==-1?(m[c]=s[g],j[c]=i[g],u&&(I[c]=u[g]),c=S[c],w.set(L,c)):i[g]();for(c=b;c<d;c++)c in m?(s[c]=m[c],i[c]=j[c],u&&(u[c]=I[c],u[c](c))):s[c]=z(y);s=s.slice(0,l=d),n=a.slice(0)}return s});function y(w){if(i[c]=w,u){const[S,m]=M(c,{name:"index"});return u[c]=m,t(a[c],S)}return t(a[c])}}}function yt(e,t,r={}){let n=[],s=[],i=[],l=[],u=0,a;return H(()=>oe(i)),()=>{const d=e()||[],g=d.length;return d[Re],A(()=>{if(g===0)return u!==0&&(oe(i),i=[],n=[],s=[],u=0,l=[]),r.fallback&&(n=[ve],s[0]=z(y=>(i[0]=y,r.fallback())),u=1),s;for(n[0]===ve&&(i[0](),i=[],n=[],s=[],u=0),a=0;a<g;a++)a<n.length&&n[a]!==d[a]?l[a](()=>d[a]):a>=n.length&&(s[a]=z(c));for(;a<n.length;a++)i[a]();return u=l.length=i.length=g,n=d.slice(0),s=s.slice(0,u)});function c(y){i[a]=y;const[w,S]=M(d[a],{name:"value"});return l[a]=S,t(w,a)}}}let Be=!1;function Nt(){Be=!0}function Ge(e,t){if(Be&&h.context){const r=h.context;N(it());const n=Ae(e,t||{});return N(r),n}return Ae(e,t||{})}function ne(){return!0}const Se={get(e,t,r){return t===ie?r:e.get(t)},has(e,t){return t===ie?!0:e.has(t)},set:ne,deleteProperty:ne,getOwnPropertyDescriptor(e,t){return{configurable:!0,enumerable:!0,get(){return e.get(t)},set:ne,deleteProperty:ne}},ownKeys(e){return e.keys()}};function ge(e){return(e=typeof e=="function"?e():e)?e:{}}function xt(){for(let e=0,t=this.length;e<t;++e){const r=this[e]();if(r!==void 0)return r}}function Ut(...e){let t=!1;for(let l=0;l<e.length;l++){const u=e[l];t=t||!!u&&ie in u,e[l]=typeof u=="function"?(t=!0,P(u)):u}if(Ve&&t)return new Proxy({get(l){for(let u=e.length-1;u>=0;u--){const a=ge(e[u])[l];if(a!==void 0)return a}},has(l){for(let u=e.length-1;u>=0;u--)if(l in ge(e[u]))return!0;return!1},keys(){const l=[];for(let u=0;u<e.length;u++)l.push(...Object.keys(ge(e[u])));return[...new Set(l)]}},Se);const r={},n=Object.create(null);for(let l=e.length-1;l>=0;l--){const u=e[l];if(!u)continue;const a=Object.getOwnPropertyNames(u);for(let d=a.length-1;d>=0;d--){const g=a[d];if(g==="__proto__"||g==="constructor")continue;const c=Object.getOwnPropertyDescriptor(u,g);if(!n[g])n[g]=c.get?{enumerable:!0,configurable:!0,get:xt.bind(r[g]=[c.get.bind(u)])}:c.value!==void 0?c:void 0;else{const y=r[g];y&&(c.get?y.push(c.get.bind(u)):c.value!==void 0&&y.push(()=>c.value))}}}const s={},i=Object.keys(n);for(let l=i.length-1;l>=0;l--){const u=i[l],a=n[u];a&&a.get?Object.defineProperty(s,u,a):s[u]=a?a.value:void 0}return s}function $t(e,...t){if(Ve&&ie in e){const s=new Set(t.length>1?t.flat():t[0]),i=t.map(l=>new Proxy({get(u){return l.includes(u)?e[u]:void 0},has(u){return l.includes(u)&&u in e},keys(){return l.filter(u=>u in e)}},Se));return i.push(new Proxy({get(l){return s.has(l)?void 0:e[l]},has(l){return s.has(l)?!1:l in e},keys(){return Object.keys(e).filter(l=>!s.has(l))}},Se)),i}const r={},n=t.map(()=>({}));for(const s of Object.getOwnPropertyNames(e)){const i=Object.getOwnPropertyDescriptor(e,s),l=!i.get&&!i.set&&i.enumerable&&i.writable&&i.configurable;let u=!1,a=0;for(const d of t)d.includes(s)&&(u=!0,l?n[a][s]=i.value:Object.defineProperty(n[a],s,i)),++a;u||(l?r[s]=i.value:Object.defineProperty(r,s,i))}return[...n,r]}function qt(e){let t,r;const n=s=>{const i=h.context;if(i){const[u,a]=M();h.count||(h.count=0),h.count++,(r||(r=e())).then(d=>{!h.done&&N(i),h.count--,a(()=>d.default),N()}),t=u}else if(!t){const[u]=at(()=>(r||(r=e())).then(a=>a.default));t=u}let l;return P(()=>(l=t())?A(()=>{if(Object.assign(l,{[Le]:!0}),!i||h.done)return l(s);const u=h.context;N(i);const a=l(s);return N(u),a}):"")};return n.preload=()=>r||((r=e()).then(s=>t=()=>s.default),r),n}let vt=0;function Wt(){return h.context?h.getNextContextId():`cl-${vt++}`}const Xe=e=>`Attempting to access a stale value from <${e}> that could possibly be undefined. This may occur because you are reading the accessor returned from the component at a time where it has already been unmounted. We recommend cleaning up any stale timers or async, or reading from the initial condition.`;function Ht(e){const t="fallback"in e&&{fallback:()=>e.fallback};return P(mt(()=>e.each,e.children,t||void 0),void 0,{name:"value"})}function _t(e){const t="fallback"in e&&{fallback:()=>e.fallback};return P(yt(()=>e.each,e.children,t||void 0),void 0,{name:"value"})}function Kt(e){const t=e.keyed,r=P(()=>e.when,void 0,{equals:(n,s)=>t?n===s:!n==!s,name:"condition"});return P(()=>{const n=r();if(n){const s=e.children;return typeof s=="function"&&s.length>0?A(()=>s(t?n:()=>{if(!A(r))throw Xe("Show");return e.when})):s}return e.fallback},void 0,{name:"value"})}function Yt(e){let t=!1;const r=(i,l)=>(t?i[1]===l[1]:!i[1]==!l[1])&&i[2]===l[2],n=He(()=>e.children),s=P(()=>{let i=n();Array.isArray(i)||(i=[i]);for(let l=0;l<i.length;l++){const u=i[l].when;if(u)return t=!!i[l].keyed,[l,u,i[l]]}return[-1]},void 0,{equals:r,name:"eval conditions"});return P(()=>{const[i,l,u]=s();if(i<0)return e.fallback;const a=u.children;return typeof a=="function"&&a.length>0?A(()=>a(t?l:()=>{if(A(s)[0]!==i)throw Xe("Match");return u.when})):a},void 0,{name:"value"})}function zt(e){return e}let Q;function Bt(){Q&&[...Q].forEach(e=>e())}function Gt(e){let t;h.context&&h.load&&(t=h.load(h.getContextId()));const[r,n]=M(t,{name:"errored"});return Q||(Q=new Set),Q.add(n),H(()=>Q.delete(n)),P(()=>{let s;if(s=r()){const i=e.fallback;return(typeof i!="function"||i.length==0)&&console.error(s),typeof i=="function"&&i.length?A(()=>i(s,()=>n())):i}return ct(()=>e.children,n)},void 0,{name:"value"})}const St=(e,t)=>e.showContent===t.showContent&&e.showFallback===t.showFallback,ke=We();function Xt(e){let[t,r]=M(()=>({inFallback:!1})),n;const s=ee(ke),[i,l]=M([]);s&&(n=s.register(P(()=>t()().inFallback)));const u=P(a=>{const d=e.revealOrder,g=e.tail,{showContent:c=!0,showFallback:y=!0}=n?n():{},w=i(),S=d==="backwards";if(d==="together"){const b=w.every(T=>!T()),k=w.map(()=>({showContent:b&&c,showFallback:y}));return k.inFallback=!b,k}let m=!1,j=a.inFallback;const I=[];for(let b=0,k=w.length;b<k;b++){const T=S?k-b-1:b,L=w[T]();if(!m&&!L)I[T]={showContent:c,showFallback:y};else{const R=!m;R&&(j=!0),I[T]={showContent:R,showFallback:!g||R&&g==="collapsed"?y:!1},m=!0}}return m||(j=!1),I.inFallback=j,I},{inFallback:!1});return r(()=>u),Ge(ke.Provider,{value:{register:a=>{let d;return l(g=>(d=g.length,[...g,a])),P(()=>u()[d],void 0,{equals:St})}},get children(){return e.children}})}function Qt(e){let t=0,r,n,s,i,l;const[u,a]=M(!1),d=ht(),g={increment:()=>{++t===1&&a(!0)},decrement:()=>{--t===0&&a(!1)},inFallback:u,effects:[],resolved:!1},c=Ue();if(h.context&&h.load){const S=h.getContextId();let m=h.load(S);if(m&&(typeof m!="object"||m.status!=="success"?s=m:h.gather(S)),s&&s!=="$$f"){const[j,I]=M(void 0,{equals:!1});i=j,s.then(()=>{if(h.done)return I();h.gather(S),N(n),I(),N()},b=>{l=b,I()})}}const y=ee(ke);y&&(r=y.register(g.inFallback));let w;return H(()=>w&&w()),Ge(d.Provider,{value:g,get children(){return P(()=>{if(l)throw l;if(n=h.context,i)return i(),i=void 0;n&&s==="$$f"&&N();const S=P(()=>e.children);return P(m=>{const j=g.inFallback(),{showContent:I=!0,showFallback:b=!0}=r?r():{};if((!j||s&&s!=="$$f")&&I)return g.resolved=!0,w&&w(),w=n=s=void 0,dt(g.effects),S();if(b)return w?m:z(k=>(w=k,n&&(N({id:n.id+"F",count:0}),n=void 0),e.fallback),c)})})}})}const Jt={hooks:W,writeSignal:Ce,registerGraph:qe};globalThis&&(globalThis.Solid$$?console.warn("You appear to have multiple instances of Solid. This can lead to unexpected behavior."):globalThis.Solid$$=!0);export{ie as $,Fe as A,Dt as B,Ue as C,Jt as D,Gt as E,Ht as F,yt as G,qt as H,_t as I,mt as J,Ut as K,Lt as L,zt as M,Pt as N,H as O,Rt as P,At as Q,Me as R,Kt as S,Bt as T,jt as U,h as V,$t as W,$e as X,A as Y,ee as Z,Ft as _,Re as a,Tt as b,M as c,Le as d,Qt as e,Xt as f,It as g,Yt as h,kt as i,ct as j,He as k,Ge as l,Te as m,We as n,Ot as o,Ne as p,P as q,Ct as r,ut as s,at as t,z as u,Et as v,Wt as w,Vt as x,Nt as y,Mt as z};
