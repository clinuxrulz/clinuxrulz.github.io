class r{constructor(i,t){this._origin=i,this._direction=t}static create(i,t){return new r(i,t)}get origin(){return this._origin}get direction(){return this._direction}positionFromTime(i){return this.origin.add(this.direction.scale(i))}closestTimeToPoint(i){return this.direction.dot(i.sub(this.origin))/this.direction.dot(this.direction)}closestPoint(i){let t=this.closestTimeToPoint(i);return this.direction.scale(t).add(this.origin)}distanceFromPoint(i){return this.closestPoint(i).distance(i)}collisionTimeWithPlane(i){var t=-(this.origin.dot(i.n)+i.d)/this.direction.dot(i.n);if(!!isFinite(t))return t}collisionWithPlane(i){let t=this.collisionTimeWithPlane(i);if(t!=null)return this.positionFromTime(t)}static closestTimeOnRay1ToRay2(i,t){let s=i.origin,c=i.direction,d=t.origin,o=t.direction,e=c.sub(o.scale(c.dot(o)/o.dot(o))),l=s.sub(d).sub(o.scale(s.sub(d).dot(o)/o.dot(o))),n=-e.dot(l)/e.dot(e);if(!(isNaN(n)||(h=>Number.NEGATIVE_INFINITY===h||Number.POSITIVE_INFINITY===h)(n)))return n}closestTimeOnThisRayWithOtherRay(i){return r.closestTimeOnRay1ToRay2(this,i)}fromSpace(i){return r.create(i.pointFromThisSpace(this.origin),i.vectorFromThisSpace(this.direction))}toSpace(i){return r.create(i.pointToThisSpace(this.origin),i.vectorToThisSpace(this.direction))}toString(){return"(origin: "+this.origin.toString()+", direction: "+this.direction.toString()+")"}}export{r as R};
