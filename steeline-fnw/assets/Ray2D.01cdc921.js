import{V as o}from"./Vec3.ce1f4f7a.js";class e{constructor(i,t){this._origin=i,this._direction=t}static fromOriginDirection(i,t){return new e(i,t)}get origin(){return this._origin}get direction(){return this._direction}intersectionTime(i){let t=-(i.getD()+this._origin.dot(i.getN()))/this._direction.dot(i.getN());if(!(isNaN(t)||(r=>Number.NEGATIVE_INFINITY===r||Number.POSITIVE_INFINITY===r)(t)))return t}closestTimeToPoint(i){return i.sub(this.origin).dot(this.direction)/this.direction.dot(this.direction)}pointFromTime(i){return o.create(this._origin.x+this._direction.x*i,this._origin.y+this._direction.y*i)}intersectionPoint(i){let t=this.intersectionTime(i);if(t!=null)return this.pointFromTime(t)}}e.__class="Ray2D";(n=>{class i{static originAndDirection(){return new n.Builder}setOrigin(r){return this.origin=r,this}setDirection(r){return this.direction=r,this}build(){if(this.origin==null||this.direction==null)throw"Fields not all set";return new n(this.origin,this.direction)}constructor(){this.origin=null,this.direction=null}}n.Builder=i,i.__class="Ray2D.Builder",i.__interfaces=["Ray2D.SetDirectionStep","Ray2D.BuildStep","Ray2D.SetOriginStep"]})(e||(e={}));export{e as R};
