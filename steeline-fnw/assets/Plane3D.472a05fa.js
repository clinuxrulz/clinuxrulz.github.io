import{a as i}from"./Vec3.ce1f4f7a.js";const n=class{constructor(t,e){this._n=t,this._d=e}static create(t,e){return new n(t,e)}static fromKnownPtAndNormal(t,e){return n.create(e,-e.dot(t))}get n(){return this._n}get d(){return this._d}moveInNormalDirection(t){return new n(this.n,this.d-t*this.n.length())}closestPoint(t){let e=-(this.d+t.dot(this.n))/this.n.dot(this.n);return t.add(this.n.scale(e))}threePlaneIntersection(t,e){let o=this,c=o.closestPoint(i.zero_$LI$()),x=t.closestPoint(i.zero_$LI$()),z=e.closestPoint(i.zero_$LI$()),s=o.n,r=t.n,l=e.n,_=r.cross(l).scale(c.dot(s)).add(l.cross(s).scale(x.dot(r))).add(s.cross(r).scale(z.dot(l))),$=s.x,a=s.y,h=s.z,y=r.x,d=r.y,P=r.z,I=l.x,w=l.y,m=l.z,u=$*(d*m-w*P)+y*(w*h-a*m)+I*(a*P-d*h);if(!(Math.abs(u)<.001))return _.scale(1/u)}fromSpace(t){let e=this.closestPoint(i.zero_$LI$()),o=t.vectorFromThisSpace(this.n),c=t.pointFromThisSpace(e);return n.fromKnownPtAndNormal(c,o)}toSpace(t){let e=this.closestPoint(i.zero_$LI$()),o=t.vectorToThisSpace(this.n),c=t.pointToThisSpace(e);return n.fromKnownPtAndNormal(c,o)}};let f=n;f.xyPlane=n.create(i.unitZ,0);export{f as P};
