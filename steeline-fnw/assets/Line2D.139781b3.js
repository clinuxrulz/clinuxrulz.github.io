import{V as h}from"./Vec3.ce1f4f7a.js";import{R as c}from"./Ray2D.01cdc921.js";class l{constructor(t,i){this._n=t,this._d=i}static fromPointAndNormal(t,i){return l.Builder.pointAndNormal().point(t).normal(i).build()}static fromPointToPoint(t,i){return l.Builder.pointToPoint().point1(t).point2(i).build()}get n(){return this._n}get d(){return this._d}getN(){return this._n}getD(){return this._d}closestPoint(t){let i=-(this._d+t.dot(this._n))/this._n.dot(this._n);return t.add(this._n.scale(i))}fromSpace(t){let i=this.closestPoint(h.zero);return l.Builder.pointAndNormal().point(t.pointFromSpace(i)).normal(t.vectorFromSpace(this._n)).build()}toSpace(t){let i=this.closestPoint(h.zero);return l.Builder.pointAndNormal().point(t.pointToSpace(i)).normal(t.vectorToSpace(this._n)).build()}getPointDistance(t){return Math.abs(t.dot(this._n)+this._d)/this._n.length()}moveInNormalDirection(t){return new l(this._n,this._d-t*this._n.length())}intersection(t){let i=this._n.cross(t._n),r=(this._d*t._n.y-t._d*this._n.y)/-i,s=(this._d*t._n.x-t._d*this._n.x)/i;if(!(isNaN(r)||(e=>Number.NEGATIVE_INFINITY===e||Number.POSITIVE_INFINITY===e)(r))&&!(isNaN(s)||(e=>Number.NEGATIVE_INFINITY===e||Number.POSITIVE_INFINITY===e)(s)))return h.create(r,s)}}l.__class="Plane2D";(o=>{class t{point1(n){return this.p1=n,this}point2(n){return this.p2=n,this}build(){if(this.p1==null||this.p2==null)throw"Fields not all set";let n=this.p2.x-this.p1.x,u=this.p2.y-this.p1.y,d=h.create(-u,n),_=-this.p1.dot(d);return new o(d,_)}constructor(){this.p1=null,this.p2=null}}o.PointToPointBuilder=t,t.__class="Plane2D.PointToPointBuilder",t.__interfaces=["Plane2D.BuildStep","Plane2D.PPPoint1Step","Plane2D.PPPoint2Step"];class i{normal(n){return this.n=n,this}d(n){return this.__d=n,this}build(){if(this.n==null)throw"Fields not all set";return new o(this.n,this.__d)}constructor(){this.n=null,this.__d=0}}o.NormalDBuilder=i,i.__class="Plane2D.NormalDBuilder",i.__interfaces=["Plane2D.BuildStep","Plane2D.NDNormalStep","Plane2D.NDDStep"];class r{point(n){return this.p=n,this}normal(n){return this.n=n,this}build(){if(this.n==null||this.p==null)throw"Fields not all set";return new o(this.n,-this.n.dot(this.p))}constructor(){this.p=null,this.n=null}}o.PointNormalBuilder=r,r.__class="Plane2D.PointNormalBuilder",r.__interfaces=["Plane2D.PNPointStep","Plane2D.PNNormalStep","Plane2D.BuildStep"];class s{static pointToPoint(){return new o.PointToPointBuilder}static normalAndD(){return new o.NormalDBuilder}static pointAndNormal(){return new o.PointNormalBuilder}constructor(){}}o.Builder=s,s.__class="Plane2D.Builder"})(l||(l={}));class a{get v1(){return this._v1}get v2(){return this._v2}constructor(t,i){this._v1=t,this._v2=i}static create(t,i){return new a(t,i)}length(){return this.v1.distance(this.v2)}lengthSquared(){return this.v1.distanceSquared(this.v2)}extendLength(t,i){let r=this.v2.sub(this.v1).normalize();return a.create(this.v1.sub(r.scale(t)),this.v2.add(r.scale(i)))}intersectOtherLine(t){let i=c.fromOriginDirection(this.v1,this.v2.sub(this.v1)),r=l.fromPointToPoint(t.v1,t.v2),s=i.intersectionTime(r);if(s==null||s<0||s>1)return;let e=i.pointFromTime(s),u=c.fromOriginDirection(t.v1,t.v2.sub(t.v1)).closestTimeToPoint(e);if(!(u<0||u>1))return e}}export{a as L,l as P};
